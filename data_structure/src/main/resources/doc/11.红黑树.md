## 红黑树

> 红黑树也是一种自平衡的二叉搜索树，以前也被称为平衡二叉B树。

红黑树必须满足以下五条性质：只要满足这五条性质，就可以保证红黑树是平衡的。

1. 节点是red或者black的。
2. 根节点必须是black的。
3. 叶子节点(外部节点，空节点：让所有的叶子节点变为度为2的节点，添加一些为null的节点，会让我们的红黑树变为真二叉树)都是black的。
4. red节点的子节点必须是black。
  - 红色节点的parent都是black。
  - 根节点到叶子节点的所有路径都不能有2个连续的red节点。
5. 从任一节点到叶子节点的所有路径都包含相同数目的black节点

![image-20210324214018018](https://gitee.com/code1997/blog-image/raw/master/images/image-20210324214018018.png)

### 1 B树

> B树是一种平衡的多路搜索树，多用于文件系统，数据库的实现。

#### 1.1 B树特点：

- 一个节点可以存储超过2个元素，可以拥有超过2个子节点。
- 拥有二叉搜索树的一些性质。
- 平衡，每个节点的所有子树高度一致。
- 树的高度比较矮。

![image-20210324214610277](https://gitee.com/code1997/blog-image/raw/master/images/image-20210324214610277.png)

#### 1.2 m阶B树的性质(m>=2)

> 数据库中常用200~300阶B树，相当于一个节点可以存储两三百个元素。

假设一个节点存储的元素个数为x。

- 根节点：1<=x<=m-1
- 非根节点：ceil(m/2)-1<=x<=m-1
  - 如果m=3，那么根节点存储元素的个数为1，2。非根节点存储的元素的个数为1。
  - 如果m=4，那么根节点存储元素的个数为1，2，3。非根节点存储的元素的个数为1，2，3。
  - 如果m=5，那么根节点存储元素的个数为1，2，3，4。非根节点存储的元素的个数为2，3，4。


如果有子节点，子节点的个数：y=x+1

- 根结点的子节点个数：2<=y<=m
- 非根节点的子节点个数：ceil(m/2)<=y<=m
  - 若m=3，2<=y<=3因此三阶B树也常称之为(2,3)树或2-3树。
  - 若m=4，2<=y<=4因此三阶B树也常称之为(2,4)树或2-3-4树。
  - 若m=5，3<=y<=5因此三阶B树也常称之为(3,5)树。

#### 1.3 B树VS二叉搜索树

> 将二叉搜索树多个节点合并，形成超级节点。
>
> n代合并，根节点最多有2^n个子节点，因此至少是2^n阶B树。例如两代合并，最多拥有4个子节点(至少是4阶b树)。

![image-20210324222341356](https://gitee.com/code1997/blog-image/raw/master/images/image-20210324222341356.png)

#### 1.4 B树操作

> 5阶B树为例。
>
> 也正是因为存在上溢和下溢，才会使得B树的每个节点的左右子树的节点的高度是一致的。

1）检索

1. 先在节点内部从小到大开始搜索元素。
2. 如果命中，搜索结束。
3. 如果没有命中，再去对应的子节点中搜索元素，重复步骤1

2）添加--上溢

1. **新添加的元素必定是添加到叶子节点**。
2. 如果某个节点的元素个数==B树的阶数，那么就会出现`上溢`。
   1. 假设上溢节点最中间的元素的位置为k
   2. 将k位置的元素向上与父节点合并。
   3. 将[0,k-1]和[k+1,m-1]位置的元素分裂成2个子节点。
   4. 2的操作可能会导致父节点上溢，那么就会继续重复1~3.极端情况是直到根节点。

图解：

![image-20210324224120073](https://gitee.com/code1997/blog-image/raw/master/images/image-20210324224120073.png)

上溢到跟根节点：使得B树的高度增加。

![image-20210324230938048](https://gitee.com/code1997/blog-image/raw/master/images/image-20210324230938048.png)

3）删除--下溢

- 如果删除的元素是叶子节点，直接删除即可。
- 如果删除的是非叶子节点。

  - 找到前驱或者后继，将删除节点覆盖掉，删除掉前驱或者后继。
- 对于B树来说，非叶子节点的前驱或者后继元素，必定在叶子节点中，因此真正删除的元素**总是**发生在叶子节点中！！！因此也出现了`下溢`的问题，即元素的个数少于B树的节点的最低限制。
  - 下溢节点的元素数量必然等于ceil(m/2)-2，即节点元素的数量小于了节点元素数量的最小值。

  - 如果下溢节点邻近的兄弟节点，有至少ceil(m/2)个元素，可以向其借一个。
    - 将父节点的元素b插入到下溢节点的0的位置(最小)。

    - 将兄弟元素最大的元素a放到父节点b位置，

    - 这个操作其实就是`旋转`的操作(对b进行旋转)。

      ![image-20210325203505369](https://gitee.com/code1997/blog-image/raw/master/images/image-20210325203505369.png)

  - 如果下溢节点邻近的兄弟节点，只有ceil(m/2)-1个元素，那么可以执行合并的操作。

    - 将父节点的元素b挪下来和左，右节点进行合并。
    - 合并后的节点元素个数等于ceil(m/2)+ceil(m/2)-2，不超过m-1个，因此不会出现上溢的情况。
    - 这个操作可能会导致父节点下溢，下溢的情况也可能会逐渐向上传播，极端情况下直到根节点。如果处于极端情况会导致B树的高度降低。

练习：逐渐添加1-20到b树中，想象添加的过程，逐渐删除1-20的删除。想象删除的过程。

#### 1.5 4阶B树--重点关照

1）性质：

- 根节点和非根节点的元素个数必定是`1<=n<=3`。
- 根节点和非根节点的字节点个数必定是`2<=n<=4`。

2）练习

- 添加：从1添加到22。
- 删除：从1删除到22。

### 2 红黑树

#### 2.1 红黑树的等价代换

- 红黑树和4阶B树具有`等价性`，将所有的red节点上提一层。

- Black节点与他的Red子节点融合在一起，形成1个B树节点。

- 红黑树的black节点个数和4阶B树的节点(对于B树来说。每一个节点都是超级节点)总个数`相等`。
- 几个概念：
  - parent：父节点。
  - sibling：兄弟节点。
  - uncle：叔父节点(parent的兄弟节点)
  - grand：祖父节点(parent的父节点)

![image-20210325210416365](https://gitee.com/code1997/blog-image/raw/master/images/image-20210325210416365.png)

红黑树VS2-3-4树

![image-20210325210830434](https://gitee.com/code1997/blog-image/raw/master/images/image-20210325210830434.png)

思考：假设上图中的black节点是不存在的，那么整个B树就只存在一个节点。

#### 2.2 添加操作

> 注意：红黑树没有平衡因子的概念，只要满足红黑树的五条性质，就可以保证树是平衡的。

![image-20211112111457879](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211112111457879.png)

如果父节点是`红色`，我们需要进行修复。

1）uncle节点不是红色

1 LL/RR

![image-20211112112436701](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211112112436701.png)

修复：

1. 染色：父节点染成黑色，祖父节点染成红色。
2. 祖父节点单旋转：黑色节点必定是父节点，因此50应该是父节点，因此需要更改指向。38->50,50->46。

2 LR/RL

![image-20211112114705147](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211112114705147.png)

修复：

1. 自己染成黑色，祖父节点染成红色
2. 旋转：双旋转操作
   1. LR：父节点左旋，祖父节点右旋。
   2. RL：父节点右旋，祖父节点左旋。

2）uncle节点是红色

1 LL-上溢

![image-20211112131119888](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211112131119888.png)

修复：

1. parent，uncle染成black
2. grand向上合并
3. grand染成红色，然后当作新添加的节点进行处理，如果最终上溢持续到根节点，需将根节点染成黑色。

2 RR-上溢

处理过程和`LL-上溢`的情况类似

3 LR-上溢

处理过程和`LL-上溢`的情况类似

3 RL-上溢

处理过程和`LL-上溢`的情况类似

代码实现：

```java
/**
 * 1.如果是根节点，染成黑色并返回
 * 2.如果父节点是黑色，不做任何处理.
 * 3.如果uncle节点是红色，将父节点和叔父节点染成黑色，祖父节点染成红色并上溢.
 * 4.如果uncle节点不是红色,根据位置进行进行合适的旋转.
 */
@Override
protected void afterAdd(Node<E> node) {
    Node<E> parent = node.parent;
    //如果添加的节点是根节点，直接染成黑色.
    if (parent == null) {
        black(node);
        return;
    }
    if (isBlack(parent)) {
        return;
    }
    Node<E> uncle = parent.sibling();
    Node<E> grand = parent.parent;
    if (isRed(uncle)) {
        //父节点和叔父节点需要染色
        black(parent);
        black(uncle);
        //祖父节点染色并向上合并
        afterAdd(red(grand));
        return;
    }
    //叔父节点不是红色，可以使用avl树的旋转
    red(grand);
    if (parent.isLeftChild()) {
        if (node.isLeftChild()) {
            black(parent);
        } else {
            black(node);
            rotateLeft(parent);
        }
        rotateRight(grand);
    } else {
        if (node.isLeftChild()) {
            black(node);
            rotateRight(parent);
        } else {
            black(parent);
        }
        rotateLeft(grand);
    }
}
```

#### 2.3 删除操作

> B树中真正被删除的元素都在叶子节点中，相对于红黑树来说，就是红黑树的最后一层。

![image-20211115220511043](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211115220511043.png)

情况分析：

1. 删除的节点是红色节点：直接删除即可

2. 删除的节点是黑色节点：

   1. 存在两个red节点的black节点：不可能直接被删除，肯定会找他的子节点代替删除，因此无需考虑。

   2. 拥有一个red节点的black节点：

      1. 判定：用于替代的子节点是red。
      2. 平衡：删除节点并将用于替代的节点变黑。

   3. black节点：用于替代的节点是黑色(NVL节点)。

      1. 判断：用于替代的子节点是黑色

      2. 平衡：

         1. 只有一个根节点：直接返回删除返回即可。

         2. 出现下溢：

            1. 兄弟必须是黑色并且兄弟存在红色子节点：可以借

               1. 进行旋转。
               2. 旋转之后的中心节点继承parent的颜色。
               3. 旋转之后的左右节点染成black。

               ![image-20211115224156520](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211115224156520.png)

            2. 兄弟节点是黑色，但是没有红节点：不能借，下溢。

               1. 父节点和兄弟节点合并

               2. 如果父节点本来是红色，父节点染色为black，兄弟节点染成红色；如果父节点本来是黑色，递归逐层下溢

                  ![image-20211115225616952](https://gitee.com/code1997/blog-image/raw/master/bigdata/image-20211115225616952.png)

            3. 删除的叶子节点的兄弟是红色：

               1. 

               





